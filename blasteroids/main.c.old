#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <allegro5/allegro.h>
#include <allegro5/allegro_primitives.h>
#include "main.h"
#include "spaceship.h"
#include "utils.h"

const char *WindowTitle = "BLASTEROIDS by Lucas59356";

typedef struct GAME {
    ALLEGRO_DISPLAY *display;
    ALLEGRO_EVENT event;
    ALLEGRO_EVENT_QUEUE *event_queue;
    ALLEGRO_THREAD *th_keyboard;
    ALLEGRO_MUTEX *mut;
    Spaceship *ship;
    int halt;
}GAME;

struct GAME *ctx;

int main() {
    printf("Iniciando...\n");
    if(catch_signal(SIGINT, handle_shutdown) == -1)
        error("Não foi possível setar o handler de interrupção");
    if (!al_init()) {
        return -1;
    }
    if (!al_init_primitives_addon()) {
        return -1;
    }
    // Alocando struct
    ctx = malloc(sizeof(struct GAME));
    // Avisando os amiguinhos pra não abandonarem o batente
    ctx->halt = 0;
    // Criando mutex
    ctx->mut = al_create_mutex();
    if (ctx->mut == NULL)
        error("Erro ao criar mutex");
    // Criando display
    ctx->display = al_create_display(600, 600);
    al_set_window_title(ctx->display, WindowTitle);
    al_flip_display();
    // Criando queue
    ctx->event_queue = al_create_event_queue();
    // Criando gancho do teclado
    if(!al_install_keyboard())
        error("Não foi possível conectar-se ao teclado");
    al_register_event_source(ctx->event_queue, al_get_keyboard_event_source());
    // Iniciando a thread do teclado
    ctx->th_keyboard = al_create_thread(handle_keyboard, NULL);
    if(!ctx->th_keyboard)
        error("Não foi possível monitorar o teclado");
    al_start_thread(ctx->th_keyboard);
    // Criando um objeto de teste
    ALLEGRO_COLOR c = al_map_rgb(255,0,0);
    Spaceship *ship;
    ship->sx = 200.0;
    ship->sy = 200.0;
    ship->heading = 2.3;
    ship->speed = 3.1;
    ship->gone = 0;
    ship->color = c;
    ctx->ship = ship;
    // Rodando o loop da renderização
    while(1) {
        al_flip_display();
        blasteroids_ship_draw(ctx->ship);
    }
    return 0;
}

void* handle_keyboard(ALLEGRO_THREAD *th, void *a) {
    printf("Esperando por eventos...\n");
    while(1) {
        if (ctx->halt) break;
        al_wait_for_event(ctx->event_queue, &ctx->event);
        if(ctx->event.type == ALLEGRO_EVENT_KEY_DOWN) {
            printf("Evento recebido\n");
            al_lock_mutex(ctx->mut);
            switch(ctx->event.keyboard.keycode) {
                case ALLEGRO_KEY_LEFT:
                    blasteroids_ship_left(ctx->ship);
                case ALLEGRO_KEY_RIGHT:
                    blasteroids_ship_right(ctx->ship);
                case ALLEGRO_KEY_UP:
                    blasteroids_ship_up(ctx->ship);
                case ALLEGRO_KEY_DOWN:
                    blasteroids_ship_down(ctx->ship);
            }
            al_unlock_mutex(ctx->mut);
        }
    }
    return NULL;
}

void handle_shutdown(int sig) {
    fprintf(stderr, "Saindo...\n");
    // Queue
    al_destroy_event_queue(ctx->event_queue);
    // Mutex
    al_destroy_mutex(ctx->mut);
    // Thread
    al_join_thread(ctx->th_keyboard, NULL);
    al_destroy_thread(ctx->th_keyboard);
    // Display
    al_destroy_display(ctx->display);
    // Liberar struct
    free(ctx);
    exit(1);
}

int catch_signal(int sig, void (*handler)(int)) {
    struct sigaction action;
    action.sa_handler = handler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    return sigaction(sig, &action, NULL);
}
